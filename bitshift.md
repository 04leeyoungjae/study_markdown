중간고사 기념(?) 비트 쉬프트 강의
===============================

이번 프원실, 어벤디 중간고사의 핵심 개념 비트쉬프트. 어렵지만 중요한 개념인 만큼 기말고사를 위해서라도 복습을 하고 가는 것이 좋다고 생각하여 제작

```C
pattern=1
for(int i=0;i<4;i++)
{
    pattern = pattern<<i | 0x01;
}
```
어벤디 문제에서 비트쉬프트가 사용되었던 문제이다. 이는 어떻게 해석해야 할까?

***
## 1. 비트쉬프트가 무엇인지 다시 한번 복습
### 1.1 비트란?
비트는 0과 1의 값을 가진 컴퓨터의 단위로, 이는 0과 1의 숫자 체계를 가진 이진수와 밀접한관계를 가지게 되는 계기가 된다.

### 1.2 비트를 왼쪽으로 밀기
unsigned char(8비트 정수)의 십진수 14는 00001110 일것이다.
이제 이를 왼쪽으로 한칸씩 옮기되, 왼쪽으로 초과한 비트는 제거하고, 오른쪽에서는 0을 새로 채우자.
```
00011100 == 십진수 28
```
그렇다면 14를 두 비트를 밀면 어떻게 될까?
```
00111000 == 십진수 56 
```
그렇다. 비트는 왼쪽으로 n칸 밀면 결과적으로 원래 수에 2의 n제곱을 곱한 것이 된다. 이는 이진수에서 1이 나타내는 값이 일괄적으로 2의 n제곱이 곱해지기 때문이다. 다시 말해 한칸을 밀면 비트 1이 나타내는 값이 2배가 된다.
### 1.3 비트를 오른쪽으로 밀기
비트를 왼쪽으로 밀면 2의 n제곱을 곱하게 된다는 것을 보았다. 그렇다면 오른쪽으로 밀면 어떻게 될까? 아마 2의 n제곱으로 나누게 된다는 것을 추론할 수 있다. 바로 14 (00001110)를 오른쪽으로 밀어보자. 왼쪽으로 밀때와 동일하게 초과한 비트는 삭제하고, 빈 비트(맨 왼쪽)는 0으로 채운다.
```
00000111 == 십진수 7
```
역시 예상대로 2의 1승, 즉 2로 나눈 값이 된다. 하지만 만약 14를 두칸 오른쪽으로 밀면 어떻게 될까?
```
00000011 == 십진수 3
```
나머지를 버리는 나눗셈, 즉 몫 나눗셈(정수 나눗셈)이 된다.
### 정리
#### n을 k비트 만큼 밀 경우
>   왼쪽으로 민다면 n * (2\**k)
>   <br> 오른쪽으로 민다면 n // (2\**k)
<hr/>

## 2. 그러면 이걸 왜 쓸까?
### 2.1 십진수를 이진수로 출력하기 (C언어)
``` C
#include <stdio.h>

void print_binary(unsigned char n)
{
    for(int i=7;i>=0;i--)
    {
        printf("%d",(n>>i) & 0x01); // 이게 뭐죠?
    }
}

int main(void)
{
    print_binary(14);
    return 0;
}
```

>   실행결과&nbsp;:&nbsp;00001110

잠깐. **(n>>i)** 는 그렇다치고, **& 0x01**은 또 무엇일까?<br/>

#### 2.1.1 비트쉬프트와 땔 수 없는 관계, 비트연산자
우리는 흔히 if문의 조건을 작성할 때 && (and) 혹은 || (or) 을 사용하곤한다.<br/>
이는 논리 연산자로, 앞과 뒤의 조건이 모두 참이여야 **True**를 반환하는 **and**와 둘중 하나의 조건만 참이여도 **True**를 반환하는 **or**이다. 그렇다면 비트 쉬프트에서 &와 |는 뭘까?
<br/>

>   <br/>**&(비트연산자 and)**<br/><hr/>
>   0x1101&nbsp;&&nbsp;0x1001 == 0x1001<br/>
>   0x0101&nbsp;&&nbsp;0x1010 == 0x0000<br/>
>   0x1110&nbsp;&&nbsp;0x1101 == 0x1100<br/><hr/>
>  같은 자리에 오는 비트를 검사하여, 두 비트 모두 1이면 1<br/>
>  하나라도 0이라면 0 <br/>
>  &nbsp;

>   <br/>**|(비트연산자 or)**<br/><hr/>
>   0x1101&nbsp;&&nbsp;0x1001 == 0x1101<br/>
>   0x0101&nbsp;&&nbsp;0x1010 == 0x1111<br/>
>   0x1110&nbsp;&&nbsp;0x1101 == 0x1111<br/><hr/>
>  같은 자리에 오는 비트를 검사하여, 두 비트 중 하나라도 1이라면 1<br/>
>  둘 모두 0이라면 0 <br/>
>  &nbsp;

이제 비트연산자에 대해서도 알게되었다.<br/>
그렇다면 다시 코드를 보자.
#### 2.1.2 (& 0x01) 의 이해
```C

    for(int i=7;i>=0;i--)
    {
        printf("%d",(n>>i) & 0x01); // & 0x01이란...
    }

```
&0x01 은 무슨 기능을 할지 14 (0x1110)를 통해 보자.
```
0x1110 & 0x01 == 00001110 & 00000001 == 0
```
15(0x1111)라면 어떨까?
```
0x1111 & 0x01 == 00001111 & 00000001 == 1
```
감이 덜잡힐 수도 있는데, 이는 결국 원래 수의 마지막 비트를 반환한다.<br/>
그러면 뒤에서 두번째 비트는 어떻게 출력할 수 있을까?
```
0x1110 >> 1 & 0x01 == 00000111 & 00000001 == 1
```
바로 비트쉬프트를 사용하면 뒤에서 두번째 비트를 출력할 수 있다.<br/>
이제 모든 준비는 끝났다. 
#### 2.1.3 코드해석
``` C
#include <stdio.h>

void print_binary(unsigned char n)
{
    for(int i=7;i>=0;i--)
    {
        printf("%d",(n>>i) & 0x01);
    }
}

int main(void)
{
    print_binary(14);
    return 0;
}
```

1. 14 == 0x1110 == 00001110 이다.
2. 이를 print_binary 함수에 매개변수로 넣는다.
3. i=7 에서 뒤에서 7+1번째 비트인 0이 출력된다.
4. i=6 에서 뒤에서 6+1번째 비트인 0이 출력된다.
5. (중략) i=3에서 3+1번쨰 비트인 1이 출력된다.
6. i=2에서 2+1번쨰 비트인 1이 출력된다.
7. i=1에서 1+1번째 비트인 1이 출력된다.
8. i=0에서 1번째 비트인 0이 출력된다.

i+1 번째인 이유는 아무것도 안밀었을때 (i=0) 마지막 비트가 출력되기 때문이다.<br/><hr/>
### 2.2 부동소수점 IEEE754 출력하기 (스스로해보기)
중간고사 이전 프원실 LAB에서 가장 어려운 파트였다. 하지만 이 역시 비트쉬프트와 비트연산자를 활용하여 쉽게 해결할 수 있다.<br/>
어차피 자료형과 관계없이 컴퓨터 안에는 이진수로 저장되어 있기에, 그냥 십진수를 이진수로 출력하듯 32비트를 출력하면 된다.
```C
#include <stdio.h>
#include <string.h>

void print_binary(float n)
{
    unsigned int copy;
    memcpy(&copy,&n,sizeof(float)); // 설명참고
    // Implement here
    /* 
    ToDo : 32비트를 출력하는 for문 만들기 
    */
    return;
}

int main(void)
{
    float n=3.141592;
    print_binary(n);
    return 0;
}
```
memcpy를 쓴 이유 : float는 비트쉬프트를 바로 할 수 없다. 하지만 Lab에서도 한번쯤 보았을 memcpy를 사용하면 비트를 그대로 유지한 상태로 자료형을 변환할 수 있다.<br/>
## 3. 다시 어벤디의 코드해석
```C
pattern=1
for(int i=0;i<2;i++)
{
    pattern = pattern<<i | 0x01;
}

for(int i=0;i<4;i++)
{
    pinMode(pin[i],(pattern>>i & 0x01));
}
```
위의 for문은 어떤 실행결과를 가질까?
> 0x1 0x11 0x111 되며 0x111이 될것임

그렇다면 아래의 for문은 어떤 실행결과를 가질까?
> pin[0]부터 pin[2]이 1, 즉 HIGH가 되어 켜짐<br/>
> 반면 pin[3]은 0, 즉 LOW가 되어 꺼짐

이상입니다.
